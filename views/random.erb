<% if @meme %>
<div class="meme-container">
  <h2 id="meme-title"><%= @meme["title"] %></h2>
  <p id="meme-subreddit" class="meme-subtitle"><%= @meme["subreddit"] %></p>

  <img id="meme-img" src="<%= @image_src %>" alt="<%= @meme["title"] %>">

  <% result = DB.execute("SELECT likes FROM meme_stats WHERE url = ?", [@image_src]).first %>
  <% @likes = result ? result["likes"] : 0 %>

  <form class="like-form" action="/like" method="POST" style="margin-top:10px;">
    <input type="hidden" name="url" value="<%= @image_src %>">
    <button type="submit" class="<%= 'liked' if session[:liked_memes]&.include?(@image_src) %>">
      <%= session[:liked_memes]&.include?(@image_src) ? "💔 Unlike" : "❤️ Like" %>
    </button>
    <span class="meme-likes"><%= @likes %></span>
  </form>
</div>
<% else %>
<p>No memes found!</p>
<% end %>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const form = document.querySelector("form.like-form");
  if (!form) return;

  const memeImg = document.getElementById("meme-img");
  const memeTitle = document.getElementById("meme-title");
  const memeSub = document.getElementById("meme-subreddit");
  const likesSpan = form.querySelector(".meme-likes");
  const likeButton = form.querySelector("button");
  const prevBtn = document.getElementById("prev-btn");
  const nextBtn = document.getElementById("next-btn");

  // Keep a local stack for previous memes
  let historyStack = [];
  let currentMeme = {
    url: memeImg.src,
    title: memeTitle.innerText,
    subreddit: memeSub.innerText,
    likes: parseInt(likesSpan.innerText)
  };

  const updateMeme = (meme) => {
    memeImg.src = meme.url;
    memeImg.alt = meme.title;
    memeTitle.innerText = meme.title;
    memeSub.innerText = meme.subreddit;
    form.querySelector("input[name='url']").value = meme.url;
    likesSpan.textContent = meme.likes || 0;
    likeButton.classList.remove("liked");
    likeButton.textContent = "❤️ Like";

    currentMeme = meme;

    // Reflect session liked memes
    if (window.sessionLikedMemes?.includes(meme.url)) {
      likeButton.textContent = "💔 Unlike";
      likeButton.classList.add("liked");
    }
  };

  const fetchMeme = async (direction) => {
    // disable while loading
    nextBtn.disabled = true;
    prevBtn.disabled = true;

    if (direction === "prev" && historyStack.length > 0) {
      const prev = historyStack.pop();
      updateMeme(prev);
      nextBtn.disabled = false;
      prevBtn.disabled = false;
      return;
    }

    // Save current meme before fetching next
    historyStack.push(currentMeme);

    try {
      const res = await fetch(`/random.json`);
      const meme = await res.json();
      updateMeme(meme);
    } catch (err) {
      console.error("Failed to fetch meme:", err);
    } finally {
      // re-enable buttons
      nextBtn.disabled = false;
      prevBtn.disabled = false;
    }
  };

  // ❤️ Like/Unlike logic
  form.addEventListener("submit", async e => {
    e.preventDefault();
    try {
      const res = await fetch(form.action, {
        method: "POST",
        body: new URLSearchParams(new FormData(form)),
        headers: { "Accept": "application/json" }
      });
      const data = await res.json();

      if (!window.sessionLikedMemes) window.sessionLikedMemes = [];
      const memeUrl = form.querySelector("input[name='url']").value;

      if (data.liked) {
        likeButton.textContent = "💔 Unlike";
        likeButton.classList.add("liked");
        if (!window.sessionLikedMemes.includes(memeUrl))
          window.sessionLikedMemes.push(memeUrl);
      } else {
        likeButton.textContent = "❤️ Like";
        likeButton.classList.remove("liked");
        window.sessionLikedMemes = window.sessionLikedMemes.filter(u => u !== memeUrl);
      }

      likesSpan.textContent = data.likes;
    } catch (err) {
      alert("Could not update like — please try again.");
      console.error(err);
    }
  });

  // Navigation
  prevBtn?.addEventListener("click", () => fetchMeme("prev"));
  nextBtn?.addEventListener("click", () => fetchMeme("next"));

  // Spacebar navigation
  document.addEventListener("keydown", e => {
    if ((e.code === "Space" || e.key === " ") && document.activeElement.tagName !== "INPUT") {
      e.preventDefault();
      fetchMeme("next");
    }
  });
});
</script>
