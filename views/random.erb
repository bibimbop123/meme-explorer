<div class="meme-container">
  <div class="meme-display" id="meme-display">
    <button class="carousel-arrow carousel-arrow-left" id="carousel-prev" aria-label="Previous image" style="display: none;">‚Äπ</button>
    <div class="meme-display-content">
      <% if @meme %>
        <% media_type = @media_type || (File.extname(@image_src).downcase == '.mp4' || File.extname(@image_src).downcase == '.webm' ? 'video' : 'image') %>
        <% if media_type == 'video' %>
          <video src="<%= @image_src %>" controls autoplay muted loop style="max-width: 100%; max-height: 100%; object-fit: contain;">
            Your browser does not support the video tag.
          </video>
        <% else %>
          <img src="<%= @image_src %>" alt="<%= @meme['title'] %>" onerror="handleImageError(this, '<%= @image_src %>')" style="max-width: 100%; max-height: 100%; object-fit: contain;">
        <% end %>
      <% else %>
        <div class="meme-loading"></div>
      <% end %>
    </div>
    <button class="carousel-arrow carousel-arrow-right" id="carousel-next" aria-label="Next image" style="display: none;">‚Ä∫</button>
    <div class="carousel-counter" id="carousel-counter" style="display: none;">1/1</div>
  </div>
  
  <div class="meme-info" id="meme-info">
    <button class="title-toggle-btn" id="title-toggle" aria-label="Toggle title visibility" title="Toggle title (T)">üëÅÔ∏è</button>
    <div class="meme-title"><%= @meme&.dig('title') || 'Loading...' %></div>
    <div class="meme-meta">
      <span class="meme-subreddit"><%= @meme&.dig('subreddit')&.upcase || 'MEME' %></span>
      <% if @reddit_path || @meme&.dig('permalink') %>
        <a href="https://reddit.com<%= @reddit_path || @meme&.dig('permalink') %>" 
           target="_blank" rel="noopener" class="reddit-link" title="View original post on Reddit">
          üîó Reddit
        </a>
      <% end %>
    </div>
  </div>

  <div class="meme-controls">
    <button class="control-btn" id="like-btn" title="Like this meme">
      ‚ù§Ô∏è
      <span class="control-count" id="like-count"><%= @likes || 0 %></span>
    </button>
    
    <button class="control-btn" id="save-btn" title="Save to profile">
      üîñ
      <span class="control-count">Save</span>
    </button>
    
    <button class="control-btn" id="share-btn" title="Share">
      üì§
      <span class="control-count">Share</span>
    </button>
    
    <button class="control-btn" id="next-btn" title="Next meme (Space or swipe)">
      ‚û°Ô∏è
      <span class="control-count">Next</span>
    </button>
  </div>

  <div class="nav-hints-container">
    <div class="nav-hint">Broccoli makes you Brolic!</div>
    <div class="nav-hint">Swipe or press Space ‚Üë</div>
    <div class="nav-hint">Press T for Title</div>
  </div>
</div>

<script>
  // ============================================
  // REQUEST DEDUPLICATION & CACHING
  // ============================================
  const requestCache = new Map();
  const pendingRequests = new Map();
  
  async function cachedFetch(url, options = {}) {
    const cacheKey = `${url}:${JSON.stringify(options)}`;
    
    // Return cached result if available and fresh (< 5s)
    if (requestCache.has(cacheKey)) {
      const { data, timestamp } = requestCache.get(cacheKey);
      if (Date.now() - timestamp < 5000) {
        console.log(`‚úÖ [CACHE HIT] ${url}`);
        return data;
      }
    }
    
    // Return pending request if already in flight (deduplicate)
    if (pendingRequests.has(cacheKey)) {
      console.log(`‚è≥ [DEDUP] Waiting for in-flight request: ${url}`);
      return pendingRequests.get(cacheKey);
    }
    
    // New request - add to pending
    const promise = fetch(url, options)
      .then(r => r.json())
      .then(data => {
        requestCache.set(cacheKey, { data, timestamp: Date.now() });
        pendingRequests.delete(cacheKey);
        return data;
      })
      .catch(err => {
        pendingRequests.delete(cacheKey);
        throw err;
      });
    
    pendingRequests.set(cacheKey, promise);
    return promise;
  }
  
  // Enhanced error handling for link image loading
  function handleImageError(img, url) {
    if (!img || !img.parentElement) return; // Prevent orphaned error handlers
    
    console.warn(`‚ö†Ô∏è [IMAGE ERROR] Failed to load: ${url}`);
    
    // Report broken image to backend for tracking
    fetch('/report-broken-image', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: `url=${encodeURIComponent(url)}`
    }).catch(e => console.log('Report error (non-critical):', e));
    
    // Fallback to local image
    img.src = '/images/funny1.jpeg';
    img.style.opacity = '0.7';
    img.title = 'Image unavailable - showing fallback';
  }
  
  let currentMeme = {
    url: <%= @image_src.to_json %>,
    subreddit: <%= (@meme&.dig("subreddit") || "reddit").to_json %>,
    title: <%= (@meme&.dig("title") || "Unknown").to_json %>
  };
  
  const likeBtn = document.getElementById('like-btn');
  const likeCount = document.getElementById('like-count');
  const saveBtn = document.getElementById('save-btn');
  const nextBtn = document.getElementById('next-btn');
  const memeImg = document.querySelector('.meme-display img');
  const memeTitle = document.querySelector('.meme-title');
  const memeSub = document.querySelector('.meme-subreddit');
  const memeInfo = document.getElementById('meme-info');
  const titleToggle = document.getElementById('title-toggle');
  
  let isLiked = window.sessionLikedMemes ? window.sessionLikedMemes.includes(currentMeme.url) : false;
  
  // Title visibility state management
  let isMobile = window.innerWidth <= 768;
  const savedVisibility = sessionStorage.getItem('titleVisible');
  let isTitleVisible = savedVisibility !== null ? savedVisibility === 'true' : true;
  
  // Initialize title visibility on page load
  function initializeTitleVisibility() {
    if (!isTitleVisible) {
      memeInfo.classList.add('title-hidden');
      memeInfo.classList.remove('title-visible');
    } else {
      memeInfo.classList.add('title-visible');
      memeInfo.classList.remove('title-hidden');
    }
  }
  
  initializeTitleVisibility();
  
  // Toggle title visibility
  function toggleTitleVisibility() {
    isTitleVisible = !isTitleVisible;
    sessionStorage.setItem('titleVisible', isTitleVisible);
    
    if (isTitleVisible) {
      memeInfo.classList.remove('title-hidden');
      memeInfo.classList.add('title-visible');
      titleToggle.classList.remove('toggle-hidden');
      titleToggle.classList.add('toggle-visible');
    } else {
      memeInfo.classList.remove('title-visible');
      memeInfo.classList.add('title-hidden');
      titleToggle.classList.remove('toggle-visible');
      titleToggle.classList.add('toggle-hidden');
    }
    
    // Haptic feedback - mobile devices
    if (navigator.vibrate) navigator.vibrate(20);
  }
  
  titleToggle.addEventListener('click', toggleTitleVisibility);
  
  // Keyboard shortcut: T key to toggle
  document.addEventListener('keydown', (e) => {
    if ((e.key === 't' || e.key === 'T') && document.activeElement.tagName !== 'INPUT') {
      toggleTitleVisibility();
    }
  });
  
  // Update like button UI
  function updateLikeUI() {
    if (isLiked) {
      likeBtn.style.color = '#ff4458';
      likeBtn.style.filter = 'drop-shadow(0 0 8px #ff4458)';
    } else {
      likeBtn.style.color = 'white';
      likeBtn.style.filter = 'none';
    }
  }
  
  updateLikeUI();
  
  // AJAX: Load next meme without full page reload (deduplicated & cached)
  let loadingMeme = false;
  
  async function loadNextMeme() {
    // Prevent concurrent loads
    if (loadingMeme) {
      console.log('‚è≥ [LOAD MEME] Already loading, skipping duplicate request');
      return;
    }
    
    loadingMeme = true;
    
    try {
      console.log('üîÑ [LOAD MEME] Starting fetch to /random.json...');
      const data = await cachedFetch('/random.json');
      
      console.log('‚úÖ [LOAD MEME] JSON received:', {
        url: data.url,
        title: data.title,
        subreddit: data.subreddit
      });
      // Update current meme object
      currentMeme = {
        url: data.url,
        subreddit: data.subreddit || 'REDDIT',
        title: data.title || 'Unknown'
      };
      
      // Update DOM - SINGLE SOURCE OF TRUTH for media updates
      updateMemeDisplay(data);
      
      // Update metadata
      memeTitle.textContent = data.title || 'Loading...';
      memeSub.textContent = (data.subreddit || 'REDDIT').toUpperCase();
      likeCount.textContent = data.likes || 0;
      
      // Reset like state for new meme
      isLiked = false;
      updateLikeUI();
      
      // Update Reddit link if available
      const redditLink = document.querySelector('.reddit-link');
      if (redditLink && data.reddit_path) {
        redditLink.href = `https://reddit.com${data.reddit_path}`;
      }
      
      // Re-initialize carousel with new meme's images
      console.log('üé† [LOAD MEME] Re-initializing carousel with new data...');
      initializeCarousel(data);
      
      // Haptic feedback
      if (navigator.vibrate) navigator.vibrate(30);
      console.log('‚úÖ [LOAD MEME] DOM updated successfully');
    } catch (e) {
      console.error('‚ùå [LOAD MEME] Error:', {
        message: e.message,
        stack: e.stack,
        type: e.constructor.name
      });
      console.warn('‚ö†Ô∏è [LOAD MEME] Falling back to full page reload...');
      // Fallback to full page reload on error
      setTimeout(() => {
        window.location.href = '/random';
      }, 100);
    } finally {
      loadingMeme = false;
    }
  }
  
  // SINGLE UPDATE FUNCTION - prevents duplicate DOM mutations
  function updateMemeDisplay(data) {
    const mediaType = data.media_type || (data.url.endsWith('.mp4') || data.url.endsWith('.webm') ? 'video' : 'image');
    const memeDisplay = document.querySelector('.meme-display');
    
    if (mediaType === 'video') {
      const existingVid = memeDisplay.querySelector('video');
      if (existingVid) {
        existingVid.src = data.url;
        existingVid.play();
      } else {
        memeDisplay.innerHTML = `<video src="${data.url}" controls autoplay muted loop style="max-width: 100%; max-height: 100%; object-fit: contain;">Your browser does not support the video tag.</video>`;
      }
    } else {
      const video = memeDisplay.querySelector('video');
      if (video) {
        video.remove();
      }
      let img = memeDisplay.querySelector('img');
      if (!img) {
        img = document.createElement('img');
        img.onerror = function() { handleImageError(this, data.url); };
        memeDisplay.querySelector('.meme-display-content').appendChild(img);
      }
      img.src = data.url;
      img.alt = data.title;
    }
  }
  
  // Like functionality (debounced - max 1 like per 500ms)
  let lastLikeTime = 0;
  likeBtn.addEventListener('click', async () => {
    const now = Date.now();
    if (now - lastLikeTime < 500) return; // Debounce
    lastLikeTime = now;
    
    try {
      const response = await fetch('/like', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: `url=${encodeURIComponent(currentMeme.url)}`
      });
      
      if (response.ok) {
        const data = await response.json();
        isLiked = data.liked;
        likeCount.textContent = data.likes;
        updateLikeUI();
        
        // Haptic feedback
        if (navigator.vibrate) navigator.vibrate(50);
      }
    } catch (e) {
      console.error('Like error:', e);
    }
  });
  
  // Save functionality (debounced)
  let lastSaveTime = 0;
  saveBtn.addEventListener('click', async () => {
    const now = Date.now();
    if (now - lastSaveTime < 500) return; // Debounce
    lastSaveTime = now;
    
    if (!<%= session[:user_id] ? 'true' : 'false' %>) {
      window.location.href = '/login';
      return;
    }
    
    try {
      const response = await fetch('/api/save-meme', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: `url=${encodeURIComponent(currentMeme.url)}&title=${encodeURIComponent(currentMeme.title)}&subreddit=${encodeURIComponent(currentMeme.subreddit)}`
      });
      
      if (response.ok) {
        saveBtn.style.color = '#ff4458';
        saveBtn.style.filter = 'drop-shadow(0 0 8px #ff4458)';
        if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
      }
    } catch (e) {
      console.error('Save error:', e);
    }
  });
  
  // Share functionality
  document.getElementById('share-btn').addEventListener('click', async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: currentMeme.title,
          text: 'Check out this meme!',
          url: window.location.href
        });
      } catch (err) {
        console.log('Share cancelled');
      }
    } else {
      // Fallback: copy to clipboard
      navigator.clipboard.writeText(window.location.href).then(() => {
        alert('Link copied!');
      });
    }
  });
  
  // Keyboard & Swipe navigation - AJAX instead of full page reload (debounced)
  let touchStartX = 0;
  let touchEndX = 0;
  let lastNavTime = 0;
  
  function debounceNav() {
    const now = Date.now();
    if (now - lastNavTime < 300) return false; // Debounce nav to 300ms
    lastNavTime = now;
    return true;
  }
  
  // Handle window resize for responsive title visibility
  window.addEventListener('resize', () => {
    const newIsMobile = window.innerWidth <= 768;
    if (newIsMobile !== isMobile) {
      // Orientation or breakpoint changed
      isMobile = newIsMobile;
    }
  });
  
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
      e.preventDefault();
      if (debounceNav()) loadNextMeme();
    }
  });
  
  document.addEventListener('touchstart', (e) => {
    touchStartX = e.changedTouches[0].screenX;
  });
  
  document.addEventListener('touchend', (e) => {
    touchEndX = e.changedTouches[0].screenX;
    if (touchStartX - touchEndX > 50 && debounceNav()) {
      // Swiped left
      loadNextMeme();
    }
  });
  
  // ============================================
  // CAROUSEL FUNCTIONALITY
  // ============================================
  
  let carouselState = {
    images: [],
    currentIndex: 0,
    totalImages: 0
  };
  
  const carouselPrevBtn = document.getElementById('carousel-prev');
  const carouselNextBtn = document.getElementById('carousel-next');
  const carouselCounter = document.getElementById('carousel-counter');
  const memeDisplayContent = document.querySelector('.meme-display-content');
  
  // Initialize carousel from JSON data
  function initializeCarousel(data) {
    carouselState.images = data.images || [];
    carouselState.currentIndex = data.current_index || 0;
    carouselState.totalImages = data.total_images || 1;
    
    console.log(`üé† [CAROUSEL] Initialized with ${carouselState.totalImages} image(s)`);
    
    // Show/hide carousel controls based on image count
    const showArrows = carouselState.totalImages > 1;
    carouselPrevBtn.style.display = showArrows ? 'block' : 'none';
    carouselNextBtn.style.display = showArrows ? 'block' : 'none';
    carouselCounter.style.display = showArrows ? 'block' : 'none';
    
    updateCarouselDisplay();
  }
  
  // Update carousel display
  function updateCarouselDisplay() {
    if (carouselState.totalImages <= 1) return;
    
    // Update counter
    carouselCounter.textContent = `${carouselState.currentIndex + 1}/${carouselState.totalImages}`;
    
    // Update arrow button states (disable at boundaries)
    carouselPrevBtn.disabled = carouselState.currentIndex === 0;
    carouselNextBtn.disabled = carouselState.currentIndex === carouselState.totalImages - 1;
    
    // Visual feedback for disabled buttons
    carouselPrevBtn.style.opacity = carouselPrevBtn.disabled ? '0.3' : '1';
    carouselNextBtn.style.opacity = carouselNextBtn.disabled ? '0.3' : '1';
  }
  
  // Navigate carousel
  function navigateCarousel(direction) {
    if (carouselState.totalImages <= 1) return;
    
    const newIndex = carouselState.currentIndex + direction;
    
    // Boundary check
    if (newIndex < 0 || newIndex >= carouselState.totalImages) return;
    
    carouselState.currentIndex = newIndex;
    
    // Update image
    const newImageUrl = carouselState.images[carouselState.currentIndex];
    if (newImageUrl) {
      const img = memeDisplayContent.querySelector('img');
      if (img) {
        img.src = newImageUrl;
        console.log(`üé† [CAROUSEL] Navigated to image ${carouselState.currentIndex + 1}`);
      }
    }
    
    updateCarouselDisplay();
    
    // Haptic feedback
    if (navigator.vibrate) navigator.vibrate(20);
  }
  
  // Arrow button click handlers
  carouselPrevBtn.addEventListener('click', () => navigateCarousel(-1));
  carouselNextBtn.addEventListener('click', () => navigateCarousel(1));
  
  // Keyboard arrow navigation (separate from Space/next meme)
  document.addEventListener('keydown', (e) => {
    if (document.activeElement.tagName === 'INPUT') return;
    
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      navigateCarousel(-1);
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      navigateCarousel(1);
    }
  });
  
  // Hook into loadNextMeme to reset carousel state
  const originalLoadNextMeme = loadNextMeme;
  loadNextMeme = async function() {
    const response = await originalLoadNextMeme.call(this);
    
    // After loading new meme, carousel will be re-initialized from JSON response
    return response;
  };
  
  // Next button click
  nextBtn.addEventListener('click', () => {
    if (debounceNav()) loadNextMeme();
  });
  
  // ============================================
  // PERFORMANCE: Prefetch next meme AFTER current media loads
  // ============================================
  let mediaLoadComplete = false;
  
  function triggerPrefetchAfterMediaLoad() {
    if (mediaLoadComplete) return; // Already triggered
    
    const img = memeDisplayContent.querySelector('img');
    const video = memeDisplayContent.querySelector('video');
    
    // Handler for when media finishes loading
    const onMediaReady = () => {
      if (mediaLoadComplete) return;
      mediaLoadComplete = true;
      
      console.log('‚úÖ [MEDIA] Load complete - safe to prefetch');
      
      // Defer prefetch to next event loop (non-blocking)
      setTimeout(() => {
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => {
            console.log('üì¶ [PREFETCH] Loading next meme during idle time...');
            cachedFetch('/random.json').catch((err) => {
              console.log('‚ÑπÔ∏è [PREFETCH] Non-critical prefetch failed:', err.message);
            });
          }, { timeout: 2000 });
        } else {
          // Fallback for browsers without requestIdleCallback
          setTimeout(() => {
            console.log('üì¶ [PREFETCH] Loading next meme (no idle callback)...');
            cachedFetch('/random.json').catch((err) => {
              console.log('‚ÑπÔ∏è [PREFETCH] Non-critical prefetch failed:', err.message);
            });
          }, 1000);
        }
      }, 0);
    };
    
    // For images: use load event
    if (img) {
      img.addEventListener('load', onMediaReady, { once: true });
      // Fallback: if image is already cached/loaded
      if (img.complete) {
        onMediaReady();
      }
    }
    
    // For videos: use loadeddata event
    if (video) {
      video.addEventListener('loadeddata', onMediaReady, { once: true });
      // Fallback: if video is already cached/loaded
      if (video.readyState >= 2) {
        onMediaReady();
      }
    }
    
    // Safety timeout: prefetch anyway after 5 seconds
    setTimeout(() => {
      if (!mediaLoadComplete) {
        console.log('‚è±Ô∏è [PREFETCH] Media load timeout - prefetching anyway');
        onMediaReady();
      }
    }, 5000);
  }
  
  // Start watching for media load completion
  triggerPrefetchAfterMediaLoad();
</script>

<style>
  footer {
    display: none;
  }

  /* MEME INFO & TITLE STYLING */
  
  .meme-info {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 1rem;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    max-width: 600px;
  }

  .meme-info.title-hidden {
    opacity: 0;
    transform: translateY(-12px) scale(0.98);
    pointer-events: none;
    max-height: 0;
    padding: 0 1rem;
    overflow: hidden;
  }

  .meme-info.title-visible {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
    max-height: 500px;
  }

  .title-toggle-btn {
    align-self: flex-end;
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 8px;
    transition: all 0.2s ease;
    opacity: 0.7;
  }

  .title-toggle-btn:hover {
    opacity: 1;
    background: rgba(0, 0, 0, 0.05);
  }

  .title-toggle-btn:active {
    transform: scale(0.9);
  }

  .meme-title {
    font-size: clamp(1.1rem, 2.5vw, 1.5rem);
    font-weight: 700;
    line-height: 1.4;
    color: #1a1a1a;
    word-wrap: break-word;
    animation: titleSlideIn 0.3s ease-out;
  }

  @keyframes titleSlideIn {
    from {
      opacity: 0;
      transform: translateY(-8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .meme-meta {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    flex-wrap: wrap;
    font-size: 0.85rem;
  }

  .meme-subreddit {
    background: linear-gradient(135deg, #ff8a00, #e52e71);
    color: white;
    padding: 0.4rem 0.75rem;
    border-radius: 20px;
    font-weight: 600;
    letter-spacing: 0.5px;
  }

  .reddit-link {
    color: #0066cc;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.2s ease;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
  }

  .reddit-link:hover {
    color: #0052a3;
    background: rgba(0, 102, 204, 0.1);
    text-decoration: underline;
  }

  .meme-display {
    width: 100%;
    max-width: 600px;
    aspect-ratio: 1;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
    overflow: hidden;
    position: relative;
  }

  .meme-display-content {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .meme-display img,
  .meme-display video {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    animation: mediaFadeIn 0.4s ease-out;
  }

  @keyframes mediaFadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  .meme-loading {
    width: 50px;
    height: 50px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  /* Carousel Arrow Styling - Desktop (default) */
  .carousel-arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    padding: 14px 18px;
    font-size: 32px;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease;
    z-index: 10;
    font-weight: bold;
    line-height: 1;
    min-width: 50px;
    text-align: center;
  }
  
  .carousel-arrow:hover:not(:disabled) {
    background: rgba(0, 0, 0, 0.9);
    transform: translateY(-50%) scale(1.15);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  }
  
  .carousel-arrow:active:not(:disabled) {
    transform: translateY(-50%) scale(0.95);
  }
  
  .carousel-arrow:disabled {
    cursor: not-allowed;
    opacity: 0.4 !important;
  }
  
  .carousel-arrow-left {
    left: 16px;
  }
  
  .carousel-arrow-right {
    right: 16px;
  }
  
  /* Carousel Counter Styling */
  .carousel-counter {
    position: absolute;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 8px 16px;
    border-radius: 24px;
    font-size: 14px;
    font-weight: 600;
    z-index: 10;
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  }
  
  /* Ensure proper positioning context */
  #meme-display {
    position: relative;
    height: 100%;
  }

  /* MEME CONTROLS STYLING */
  .meme-controls {
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 0.75rem;
    flex-wrap: wrap;
    max-width: 600px;
  }

  .control-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.4rem;
    padding: 0.75rem 1.25rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 1.2rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    min-height: 48px;
    flex: 1 1 auto;
    max-width: 140px;
  }

  .control-btn:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.5);
  }

  .control-btn:active {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
  }

  .control-count {
    font-size: 0.75rem;
    opacity: 0.9;
    letter-spacing: 0.5px;
  }

  .meme-container {
    width: 100%;
    max-width: 600px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.25rem;
    padding: 1.5rem 1rem;
  }

  .nav-hints-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    max-width: 600px;
    padding: 0 1rem;
  }

  .nav-hint {
    font-size: 0.85rem;
    color: #666;
    text-align: center;
    font-weight: 500;
    letter-spacing: 0.3px;
    animation: fadeInUp 0.5s ease-out;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Tablet Responsiveness (768px and below) */
  @media (max-width: 768px) {
    .carousel-arrow {
      padding: 12px 16px;
      font-size: 28px;
      min-width: 46px;
    }
    
    .carousel-arrow-left {
      left: 12px;
    }
    
    .carousel-arrow-right {
      right: 12px;
    }
    
    .carousel-counter {
      bottom: 14px;
      padding: 7px 14px;
      font-size: 13px;
    }
  }
  
  /* Mobile Responsiveness (480px and below) */
  @media (max-width: 480px) {
    .carousel-arrow {
      padding: 10px 12px;
      font-size: 24px;
      min-width: 40px;
      border-radius: 4px;
    }
    
    .carousel-arrow:hover:not(:disabled) {
      transform: translateY(-50%) scale(1.1);
    }
    
    .carousel-arrow-left {
      left: 6px;
    }
    
    .carousel-arrow-right {
      right: 6px;
    }
    
    .carousel-counter {
      bottom: 10px;
      padding: 5px 10px;
      font-size: 11px;
      border-radius: 16px;
    }
  }
</style>
