<div class="meme-container">
  <!-- Genre Filter Bar -->
  <div class="genre-filter-bar">
    <button class="genre-btn active" data-genre="all" title="All memes">üé≤ All</button>
    <button class="genre-btn" data-genre="funny" title="Funny memes">üòÇ Funny</button>
    <button class="genre-btn" data-genre="dank" title="Dank memes">üî• Dank</button>
    <button class="genre-btn" data-genre="wholesome" title="Wholesome memes">üíö Wholesome</button>
    <button class="genre-btn" data-genre="selfcare" title="Self-care memes">üßò Self-Care</button>
  </div>

  <!-- Stats Display -->
  <div class="stats-bar">
    <div class="stat-item">
      <span class="stat-value" id="streak-counter">üî• 0</span>
    </div>
    <div class="stat-item">
      <span class="stat-value" id="daily-likes">‚ù§Ô∏è 0</span>
    </div>
  </div>

  <div class="meme-display">
    <% if @meme %>
      <% media_type = @media_type || (File.extname(@image_src).downcase == '.mp4' || File.extname(@image_src).downcase == '.webm' ? 'video' : 'image') %>
      <% if media_type == 'video' %>
        <video src="<%= @image_src %>" controls autoplay muted loop style="max-width: 100%; max-height: 100%; object-fit: contain;">
          Your browser does not support the video tag.
        </video>
      <% else %>
        <img src="<%= @image_src %>" alt="<%= @meme['title'] %>" onerror="this.src='/images/funny1.jpeg'">
      <% end %>
    <% else %>
      <div class="meme-loading"></div>
    <% end %>
    <!-- Skeleton Loader -->
    <div class="skeleton-loader" id="skeleton-loader" style="display: none;"></div>
  </div>
  
  <div class="meme-info" id="meme-info">
    <button class="title-toggle-btn" id="title-toggle" aria-label="Toggle title visibility" title="Toggle title (T)">üëÅÔ∏è</button>
    <div class="meme-title"><%= @meme&.dig('title') || 'Loading...' %></div>
    <div class="meme-meta">
      <span class="meme-subreddit"><%= @meme&.dig('subreddit')&.upcase || 'MEME' %></span>
      <% if @reddit_path || @meme&.dig('permalink') %>
        <a href="https://reddit.com<%= @reddit_path || @meme&.dig('permalink') %>" 
           target="_blank" rel="noopener" class="reddit-link" title="View original post on Reddit">
          üîó Reddit
        </a>
      <% end %>
    </div>
  </div>

  <div class="meme-controls">
    <button class="control-btn" id="back-btn" title="Go back (Backspace)" style="display: none;">
      ‚¨ÖÔ∏è
      <span class="control-count">Back</span>
    </button>

    <button class="control-btn" id="like-btn" title="Like this meme">
      ‚ù§Ô∏è
      <span class="control-count" id="like-count"><%= @likes || 0 %></span>
    </button>
    
    <button class="control-btn" id="save-btn" title="Save to profile">
      üîñ
      <span class="control-count">Save</span>
    </button>
    
    <button class="control-btn" id="share-btn" title="Share">
      üì§
      <span class="control-count">Share</span>
    </button>
    
    <button class="control-btn" id="next-btn" title="Next meme (Space or swipe)">
      ‚û°Ô∏è
      <span class="control-count">Next</span>
    </button>
  </div>

  <div class="nav-hints-container">
    <div class="nav-hint">Broccoli makes you Brolic!</div>
    <div class="nav-hint">Swipe or press Space ‚Üë</div>
    <div class="nav-hint">Press T for Title</div>
  </div>
</div>

<script>
  // Enhanced Random Feature with UX Improvements
  
  let currentMeme = {
    url: <%= @image_src.to_json %>,
    subreddit: <%= (@meme&.dig("subreddit") || "reddit").to_json %>,
    title: <%= (@meme&.dig("title") || "Unknown").to_json %>
  };
  
  // Session History Manager
  class MemeHistory {
    constructor(maxSize = 15) {
      this.stack = JSON.parse(sessionStorage.getItem('memeHistory') || '[]');
      this.maxSize = maxSize;
    }
    
    push(meme) {
      this.stack.push(JSON.parse(JSON.stringify(meme)));
      if (this.stack.length > this.maxSize) {
        this.stack.shift();
      }
      this.save();
    }
    
    pop() {
      if (this.stack.length === 0) return null;
      const meme = this.stack.pop();
      this.save();
      return meme;
    }
    
    canGoBack() {
      return this.stack.length > 0;
    }
    
    save() {
      sessionStorage.setItem('memeHistory', JSON.stringify(this.stack));
    }
  }
  
  // Daily Streak Tracker
  class StreakTracker {
    constructor() {
      this.data = JSON.parse(localStorage.getItem('streakData') || '{"streak":0,"lastActive":"","todayLikes":0}');
      this.initializeDaily();
    }
    
    initializeDaily() {
      const today = new Date().toISOString().split('T')[0];
      if (this.data.lastActive !== today) {
        const lastDate = new Date(this.data.lastActive);
        const todayDate = new Date(today);
        const daysDiff = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));
        
        if (daysDiff === 1) {
          this.data.streak = (this.data.streak || 0) + 1;
        } else if (daysDiff > 1) {
          this.data.streak = 1;
        }
        this.data.lastActive = today;
        this.data.todayLikes = 0;
        this.save();
      }
    }
    
    recordLike() {
      this.data.todayLikes = (this.data.todayLikes || 0) + 1;
      this.save();
    }
    
    getStreak() {
      return this.data.streak || 0;
    }
    
    getTodayLikes() {
      return this.data.todayLikes || 0;
    }
    
    save() {
      localStorage.setItem('streakData', JSON.stringify(this.data));
    }
  }
  
  // Genre Filter Manager
  class GenreFilterManager {
    constructor() {
      this.activeGenre = localStorage.getItem('activeGenre') || 'all';
      this.setupButtons();
    }
    
    setupButtons() {
      document.querySelectorAll('.genre-btn').forEach(btn => {
        if (btn.dataset.genre === this.activeGenre) {
          btn.classList.add('active');
        }
        btn.addEventListener('click', () => this.selectGenre(btn.dataset.genre));
      });
    }
    
    selectGenre(genre) {
      this.activeGenre = genre;
      localStorage.setItem('activeGenre', genre);
      document.querySelectorAll('.genre-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.genre === genre);
      });
      loadNextMeme();
    }
    
    getActiveGenre() {
      return this.activeGenre;
    }
  }
  
  // Initialize managers
  const history = new MemeHistory();
  const streakTracker = new StreakTracker();
  const genreFilter = new GenreFilterManager();
  
  // Push initial meme to history
  history.push(currentMeme);
  
  const likeBtn = document.getElementById('like-btn');
  const likeCount = document.getElementById('like-count');
  const saveBtn = document.getElementById('save-btn');
  const nextBtn = document.getElementById('next-btn');
  const memeImg = document.querySelector('.meme-display img');
  const memeTitle = document.querySelector('.meme-title');
  const memeSub = document.querySelector('.meme-subreddit');
  const memeInfo = document.getElementById('meme-info');
  const titleToggle = document.getElementById('title-toggle');
  
  let isLiked = window.sessionLikedMemes ? window.sessionLikedMemes.includes(currentMeme.url) : false;
  
  // Title visibility state management
  let isMobile = window.innerWidth <= 768;
  const savedVisibility = sessionStorage.getItem('titleVisible');
  let isTitleVisible = savedVisibility !== null ? savedVisibility === 'true' : true;
  
  // Initialize title visibility on page load
  function initializeTitleVisibility() {
    if (!isTitleVisible) {
      memeInfo.classList.add('title-hidden');
      memeInfo.classList.remove('title-visible');
    } else {
      memeInfo.classList.add('title-visible');
      memeInfo.classList.remove('title-hidden');
    }
  }
  
  initializeTitleVisibility();
  
  // Toggle title visibility
  function toggleTitleVisibility() {
    isTitleVisible = !isTitleVisible;
    sessionStorage.setItem('titleVisible', isTitleVisible);
    
    if (isTitleVisible) {
      memeInfo.classList.remove('title-hidden');
      memeInfo.classList.add('title-visible');
      titleToggle.classList.remove('toggle-hidden');
      titleToggle.classList.add('toggle-visible');
    } else {
      memeInfo.classList.remove('title-visible');
      memeInfo.classList.add('title-hidden');
      titleToggle.classList.remove('toggle-visible');
      titleToggle.classList.add('toggle-hidden');
    }
    
    // Haptic feedback - mobile devices
    if (navigator.vibrate) navigator.vibrate(20);
  }
  
  titleToggle.addEventListener('click', toggleTitleVisibility);
  
  // Keyboard shortcut: T key to toggle
  document.addEventListener('keydown', (e) => {
    if ((e.key === 't' || e.key === 'T') && document.activeElement.tagName !== 'INPUT') {
      toggleTitleVisibility();
    }
  });
  
  // Update like button UI
  function updateLikeUI() {
    if (isLiked) {
      likeBtn.style.color = '#ff4458';
      likeBtn.style.filter = 'drop-shadow(0 0 8px #ff4458)';
    } else {
      likeBtn.style.color = 'white';
      likeBtn.style.filter = 'none';
    }
  }
  
  updateLikeUI();
  
  // Update UI displays
  function updateStatsDisplay() {
    const streak = streakTracker.getStreak();
    const todayLikes = streakTracker.getTodayLikes();
    document.getElementById('streak-counter').textContent = `üî• ${streak}`;
    document.getElementById('daily-likes').textContent = `‚ù§Ô∏è ${todayLikes}`;
  }
  
  // Show/hide back button
  function updateBackButton() {
    const backBtn = document.getElementById('back-btn');
    backBtn.style.display = history.canGoBack() ? 'inline-block' : 'none';
  }
  
  // Show/hide skeleton loader
  function showSkeleton() {
    document.getElementById('skeleton-loader').style.display = 'block';
  }
  
  function hideSkeleton() {
    document.getElementById('skeleton-loader').style.display = 'none';
  }
  
  // AJAX: Load next meme without full page reload
  async function loadNextMeme() {
    try {
      showSkeleton();
      const genre = genreFilter.getActiveGenre();
      const endpoint = genre === 'all' ? '/random.json' : `/random.json?genre=${genre}`;
      
      console.log('üîÑ [LOAD MEME] Fetching with genre:', genre);
      const response = await fetch(endpoint);
      
      console.log('üîÑ [LOAD MEME] Response received:', {
        status: response.status,
        ok: response.ok,
        statusText: response.statusText,
        contentType: response.headers.get('content-type')
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
      }
      
      const data = await response.json();
      console.log('‚úÖ [LOAD MEME] JSON parsed successfully:', {
        url: data.url,
        title: data.title,
        subreddit: data.subreddit,
        category: data.category
      });
      
      // Update current meme object
      currentMeme = {
        url: data.url,
        subreddit: data.subreddit || 'REDDIT',
        title: data.title || 'Unknown',
        category: data.category || 'all'
      };
      
      // Add to history
      history.push(currentMeme);
      updateBackButton();
      
      // Update DOM - handle both images and videos
      const mediaType = data.media_type || (data.url.endsWith('.mp4') || data.url.endsWith('.webm') ? 'video' : 'image');
      const memeDisplay = document.querySelector('.meme-display');
      
      if (mediaType === 'video') {
        // Replace image with video
        const existingVid = memeDisplay.querySelector('video');
        if (existingVid) {
          existingVid.src = data.url;
          existingVid.play();
        } else {
          memeDisplay.innerHTML = `<video src="${data.url}" controls autoplay muted loop style="max-width: 100%; max-height: 100%; object-fit: contain;">Your browser does not support the video tag.</video>`;
        }
      } else {
        // Replace video with image
        const existingVid = memeDisplay.querySelector('video');
        if (existingVid) {
          memeDisplay.innerHTML = `<img src="${data.url}" alt="${data.title}" onerror="this.src='/images/funny1.jpeg'">`;
        } else {
          memeImg.src = data.url;
          memeImg.alt = data.title;
        }
      }
      
      memeTitle.textContent = data.title || 'Loading...';
      memeSub.textContent = (data.subreddit || 'REDDIT').toUpperCase();
      likeCount.textContent = data.likes || 0;
      
      // Reset like state for new meme
      isLiked = false;
      updateLikeUI();
      
      // Update Reddit link if available
      const redditLink = document.querySelector('.reddit-link');
      if (redditLink && data.reddit_path) {
        redditLink.href = `https://reddit.com${data.reddit_path}`;
      }
      
      // Haptic feedback
      if (navigator.vibrate) navigator.vibrate(30);
      hideSkeleton();
      console.log('‚úÖ [LOAD MEME] DOM updated successfully');
    } catch (e) {
      console.error('‚ùå [LOAD MEME] Error:', {
        message: e.message,
        stack: e.stack,
        type: e.constructor.name
      });
      console.warn('‚ö†Ô∏è [LOAD MEME] Falling back to full page reload...');
      hideSkeleton();
      setTimeout(() => {
        window.location.href = '/random';
      }, 100);
    }
  }
  
  // Back button functionality
  document.getElementById('back-btn').addEventListener('click', async () => {
    const previousMeme = history.pop();
    if (previousMeme) {
      history.pop(); // Remove current that was just pushed
      
      showSkeleton();
      currentMeme = previousMeme;
      
      const memeDisplay = document.querySelector('.meme-display');
      const memeImg = memeDisplay.querySelector('img');
      if (memeImg) {
        memeImg.src = previousMeme.url;
        memeImg.alt = previousMeme.title;
      }
      
      memeTitle.textContent = previousMeme.title || 'Loading...';
      memeSub.textContent = (previousMeme.subreddit || 'REDDIT').toUpperCase();
      
      isLiked = false;
      updateLikeUI();
      
      hideSkeleton();
      updateBackButton();
      
      if (navigator.vibrate) navigator.vibrate([20, 10, 20]);
    }
  });
  
  // Like functionality with streak tracking
  likeBtn.addEventListener('click', async () => {
    try {
      const response = await fetch('/like', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: `url=${encodeURIComponent(currentMeme.url)}`
      });
      
      if (response.ok) {
        const data = await response.json();
        isLiked = data.liked;
        likeCount.textContent = data.likes;
        updateLikeUI();
        
        // Track like for daily stats
        if (isLiked) {
          streakTracker.recordLike();
          updateStatsDisplay();
        }
        
        // Haptic feedback
        if (navigator.vibrate) navigator.vibrate(50);
      }
    } catch (e) {
      console.error('Like error:', e);
    }
  });
  
  // Save functionality
  saveBtn.addEventListener('click', async () => {
    if (!<%= session[:user_id] ? 'true' : 'false' %>) {
      window.location.href = '/login';
      return;
    }
    
    try {
      const response = await fetch('/api/save-meme', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: `url=${encodeURIComponent(currentMeme.url)}&title=${encodeURIComponent(currentMeme.title)}&subreddit=${encodeURIComponent(currentMeme.subreddit)}`
      });
      
      if (response.ok) {
        saveBtn.style.color = '#ff4458';
        saveBtn.style.filter = 'drop-shadow(0 0 8px #ff4458)';
        if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
      }
    } catch (e) {
      console.error('Save error:', e);
    }
  });
  
  // Share functionality
  document.getElementById('share-btn').addEventListener('click', async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: currentMeme.title,
          text: 'Check out this meme!',
          url: window.location.href
        });
      } catch (err) {
        console.log('Share cancelled');
      }
    } else {
      // Fallback: copy to clipboard
      navigator.clipboard.writeText(window.location.href).then(() => {
        alert('Link copied!');
      });
    }
  });
  
  // Keyboard & Swipe navigation - AJAX instead of full page reload
  let touchStartX = 0;
  let touchEndX = 0;
  
  // Handle window resize for responsive title visibility
  window.addEventListener('resize', () => {
    const newIsMobile = window.innerWidth <= 768;
    if (newIsMobile !== isMobile) {
      // Orientation or breakpoint changed
      isMobile = newIsMobile;
    }
  });
  
  document.addEventListener('keydown', (e) => {
    if ((e.code === 'Space' || e.code === 'ArrowRight') && document.activeElement.tagName !== 'INPUT') {
      e.preventDefault();
      loadNextMeme();
    }
    // Backspace to go back
    if (e.code === 'Backspace' && document.activeElement.tagName !== 'INPUT' && history.canGoBack()) {
      e.preventDefault();
      document.getElementById('back-btn').click();
    }
  });
  
  document.addEventListener('touchstart', (e) => {
    touchStartX = e.changedTouches[0].screenX;
  });
  
  document.addEventListener('touchend', (e) => {
    touchEndX = e.changedTouches[0].screenX;
    if (touchStartX - touchEndX > 50) {
      // Swiped left
      loadNextMeme();
    }
  });
  
  // Next button click
  nextBtn.addEventListener('click', () => {
    loadNextMeme();
  });
  
  // Initialize displays
  updateStatsDisplay();
  updateBackButton();
</script>

<style>
  footer {
    display: none;
  }
  
  @keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }
  
  .genre-filter-bar {
    display: flex;
    gap: 8px;
    justify-content: center;
    padding: 12px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 12px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }
  
  .genre-btn {
    padding: 8px 16px;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    color: white;
    border-radius: 20px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    white-space: nowrap;
  }
  
  .genre-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-2px);
  }
  
  .genre-btn.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-color: #764ba2;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
  }
  
  .stats-bar {
    display: flex;
    gap: 16px;
    justify-content: center;
    padding: 10px;
    margin-bottom: 8px;
    font-size: 14px;
    font-weight: 600;
    color: white;
  }
  
  .stat-item {
    display: flex;
    align-items: center;
    gap: 6px;
    background: rgba(0, 0, 0, 0.2);
    padding: 6px 12px;
    border-radius: 8px;
  }
  
  .stat-value {
    font-weight: bold;
    color: #ffd700;
  }
  
  .skeleton-loader {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    border-radius: 8px;
  }
  
  .meme-display {
    position: relative;
  }
</style>
